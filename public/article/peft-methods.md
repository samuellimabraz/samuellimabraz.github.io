# PEFT: Parameter-Efficient Fine-Tuning Methods for LLMs

<div style="text-align: justify;">
In the constrained and costly landscape of LLMs, where large organizations employ extraordinarily complex computational capabilities to create general-purpose language models, PEFT emerges as a valuable alternative—not only to reduce costs but also to enable specification and control.
</div>

![image/jpeg](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/K26QSN3Y5dE-rY2bGKymc.jpeg)
<div style="text-align: center; font-size: smaller;">
Source: Image generated by the model <a href="https://huggingface.co/black-forest-labs/FLUX.1-dev">FLUX.1 [dev]</a>
</div>

<details>
<summary><strong>Contents</strong></summary>
  
  - [Introduction](#introduction)

  - [Categories of PEFT Methods](#categories-of-peft-methods)

  - [Additive Methods](#additive-methods)

    - [Adapters](#adapters)

    - [Soft Prompts](#soft-prompts)

      - [Prompt Tuning](#prompt-tuning)

      - [Prefix Tuning](#prefix-tuning)

      - [P-tuning](#p-tuning)

    - [IA³](#ia³)

  - [Reparameterization-based Methods](#reparameterization-based-methods)

    - [Intrinsic SAID](#intrinsic-said)

    - [Low-Rank Adaptation (LoRA)](#low-rank-adaptation-lora)
   
      - [Quantized Low-Rank Adaptation (QLoRA)](#quantized-low-rank-adaptation-qlora)

      - [Initialization](#initialization)

        - [PiSSA](#pissa)

        - [OLoRA](#olora)

        - [Rank-stabilized LoRA (rsLoRA)](#rank-stabilized-lora-rslora)

        - [Weight-Decomposed Low-Rank Adaptation (DoRA)](#weight-decomposed-low-rank-adaptation-dora)

      - [Merge LoRA Adapter](#merge-lora-adapter)

      - [Variants](#variants)

        - [Low-Rank Hadamard Product (LoHa)](#low-rank-hadamard-product-loha)

        - [Low-Rank Kronecker Product (LoKr)](#low-rank-kronecker-product-lokr)
          
        - [Mixture of LoRA Experts (X-LoRA)](#mixture-of-lora-experts-x-lora)

    - [KronA](#krona)

  - [Selective Methods](#selective-methods)

    - [BitFit](#bitfit)
    
    - [DiffPruning](#diffpruning)
    
    - [Freeze and Reconfigure (FAR)](#freeze-and-reconfigure-far)
    
    - [FishMask](#fishmask)

  - [References](#references)
</details>

<div style="text-align: justify;">
  
## Introduction 

This article explores the universe of Parameter-Efficient Fine-Tuning (PEFT) techniques—a set of approaches that enable the adaptation of large language models (LLMs) more efficiently in terms of memory and computational performance. Drawing from the paper “[\[2303.15647\] Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning](https://arxiv.org/abs/2303.15647)” and the [PEFT library](https://huggingface.co/docs/peft/index), integrated with Hugging Face's Transformers, this study delves into the key concepts and methodologies that facilitate fine-tuning language models without the need to train all of their billions of parameters.

This article provides an introduction to the main PEFT techniques, describing how they work and highlighting their characteristics and potential applications for fine-tuning language models, with a focus on maximizing memory efficiency and training time performance.

And also a notebook performing fine-tuning of a model for summarizing customer service conversations, using Full Fine-Tune, LoRA, QLoRA and IA3

<p>
  <a href="https://colab.research.google.com/drive/1B9RsKLMa8SwTxLsxRT8g9OedK10zfBEP?usp=sharing" target="_blank">
    <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open in Colab">
  </a>
</p>



## Categories of PEFT Methods

Parameter-Efficient Fine-Tuning (PEFT) methods can be classified according to two main aspects: their conceptual structure (e.g., introducing new parameters or adjusting existing ones) and their primary objective (minimizing memory footprint, improving storage efficiency, or reducing computational costs).  

![PEFT Methods](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/dz0AdSqt4QP7iRjpiXDE1.png)

<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2303.15647">[2303.15647] Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning</a>
</div>


These methods are divided into three broad categories:  

**Additive Methods**  

Additive methods introduce new parameters to the base model, often through small adapter layers or by adjusting a part of the input embeddings (known as soft prompts). These methods are widely used and include:  

* **Adapters**: Small dense (fully connected) networks inserted after specific transformer sublayers, allowing adaptation to new tasks without the need to train all the model's parameters.  
* **Soft Prompts**: Fine-tuning applied directly to the model's input embeddings, enabling task-specific adaptation without modifying the model's internal parameters.  

These methods are generally memory-efficient as they reduce the size of gradients and optimizer states.  

**Selective Methods**  

Selective methods adjust only a fraction of the existing model parameters. This can be done in several ways, such as:  

* **Top Layer Fine-Tuning**: Focusing on fine-tuning only the upper layers of the network while leaving the lower layers untouched.  
* **Specific Parameter Fine-Tuning**: Selectively training certain types of parameters, such as biases, while freezing other parameters.  
* **Sparse Updates**: Selecting a specific subset of parameters for training. While promising, this approach can be computationally expensive due to the need to identify the most relevant parameters.  

Despite reducing the number of trained parameters, selective methods may incur high computational costs, especially in sparse configurations.  

**Reparameterization-Based Methods**  

Reparameterization-based methods reduce the number of trainable parameters by utilizing low-rank representations, leveraging the redundancy present in neural networks. Key methods include:  

* **LoRa** (Low-Rank Adaptation): Employs low-rank matrix decomposition to represent weight updates, providing an efficient way to fine-tune models.  
* **Intrinsic SAID**: Utilizes the Fastfood transform, a technique for efficiently representing low-rank updates.  

These methods significantly reduce the number of parameters to be trained, making them ideal for scenarios where storage efficiency and training time are critical.  

**Additional Points**  

* **Additive Methods**: While they introduce new parameters, they can be more memory-efficient overall by reducing the amount of gradients and optimizer states that need to be stored.  
* **Selective Methods**: Although promising for reducing the number of trained parameters, they can be computationally intensive, particularly in cases of sparse updates.  
* **Hybrid Methods**: Combinations of ideas from different categories are often explored to maximize performance, leveraging the strengths of each approach.  

<table border="1">
  <thead>
    <tr>
      <th>Method</th>
      <th>Type</th>
      <th>Storage</th>
      <th>Memory</th>
      <th>Backprop</th>
      <th>Inference overhead</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Adapters (Houlsby et al., 2019)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN</td>
    </tr>
    <tr>
      <td>AdaMix (Wang et al., 2022)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN</td>
    </tr>
    <tr>
      <td>SparseAdapter (He et al., 2022b)</td>
      <td><span style="color: #96cdf6;">A</span><span style="color: #fce387;">S</span></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN</td>
    </tr>
    <tr>
      <td>Cross-Attn tuning (Gheini et al., 2021)</td>
      <td style="color: #fce387;">S</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>BitFit (Ben-Zaken et al., 2021)</td>
      <td style="color: #fce387;">S</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>DiffPruning (Guo et al., 2020)</td>
      <td style="color: #fce387;">S</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>Fish-Mask (Sung et al., 2021)</td>
      <td style="color: #fce387;">S</td>
      <td style="color: green;">yes</td>
      <td style="color: #f8a291;">maybe</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>LT-SFT (Ansell et al., 2022)</td>
      <td style="color: #fce387;">S</td>
      <td style="color: green;">yes</td>
      <td style="color: #f8a291;">maybe</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>Prompt Tuning (Lester et al., 2021)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra input</td>
    </tr>
    <tr>
      <td>Prefix-Tuning (Li and Liang, 2021)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra input</td>
    </tr>
    <tr>
      <td>Spot (Vu et al., 2021)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra input</td>
    </tr>
    <tr>
      <td>IPT (Qin et al., 2021)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN and input</td>
    </tr>
    <tr>
      <td>MAM Adapter (He et al., 2022a)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN and input</td>
    </tr>
    <tr>
      <td>Parallel Adapter (He et al., 2022a)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN</td>
    </tr>
    <tr>
      <td>Intrinsic SAID (Aghajanyan et al., 2020)</td>
      <td style="color: #f8a291;">R</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>LoRa (Hu et al., 2021)</td>
      <td style="color: #f8a291;">R</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>UniPELT (Mao et al., 2021)</td>
      <td><span style="color: #96cdf6;">A</span><span style="color: #f8a291;">R</span></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN and input</td>
    </tr>
    <tr>
      <td>Compacter (Karimi Mahabadi et al., 2021)</td>
      <td><span style="color: #96cdf6;">A</span><span style="color: #f8a291;">R</span></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN</td>
    </tr>
    <tr>
      <td>PHM Adapter (Karimi Mahabadi et al., 2021)</td>
      <td><span style="color: #96cdf6;">A</span><span style="color: #f8a291;">R</span></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN</td>
    </tr>
    <tr>
      <td>KronA (Edalati et al., 2022)</td>
      <td style="color: #f8a291;">R</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>KronA_Bres (Edalati et al., 2022)</td>
      <td><span style="color: #96cdf6;">A</span><span style="color: #f8a291;">R</span></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra linear layer</td>
    </tr>
    <tr>
      <td>(IA)³ (Liu et al., 2022)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra gating</td>
    </tr>
    <tr>
      <td>Attention Fusion (Cao et al., 2022)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: gray;">Extra decoder</td>
    </tr>
    <tr>
      <td>LeTS (Fu et al., 2021)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: gray;">Extra FFN</td>
    </tr>
    <tr>
      <td>Ladder Side-Tuning (Sung et al., 2022)</td>
      <td style="color: #96cdf6;">A</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: gray;">Extra decoder</td>
    </tr>
    <tr>
      <td>FAR (Vucetic et al., 2022)</td>
      <td style="color: #fce387;">S</td>
      <td style="color: green;">yes</td>
      <td style="color: #f8a291;">maybe</td>
      <td style="color: red;">no</td>
      <td style="color: green;">No overhead</td>
    </tr>
    <tr>
      <td>S4-model (Chen et al., 2023)</td>
      <td><span style="color: #96cdf6;">A</span><span style="color: #f8a291;">R</span><span style="color: #fce387;">S</span></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: gray;">Extra FFN and input</td>
    </tr>
  </tbody>
</table>
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2303.15647">[2303.15647] Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning</a>
</div>

The table above presents a detailed comparison of PEFT methods in terms of storage efficiency, memory efficiency, and computational efficiency. It examines the reduction of backpropagation costs during training and the inference overhead associated with each method. The different techniques are classified as follows:  

* **A (Additive)**: Methods that introduce new parameters into the model.  
* **S (Selective)**: Methods that fine-tune only a subset of existing parameters.  
* **R (Reparameterization)**: Methods that utilize low-rank representations to reduce the number of trainable parameters.


<table border="1">
  <thead>
    <tr>
      <th>Method</th>
      <th>% Trainable parameters</th>
      <th>% Changed parameters</th>
      <th colspan="3">Evaluated on</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th></th>
      <th>&lt;1B</th>
      <th>&lt;20B</th>
      <th>&gt;20B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Adapters (Houlsby et al., 2019)</td>
      <td>0.1 - 6</td>
      <td>0.1 - 6</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
    </tr>
    <tr>
      <td>AdaMix (Wang et al., 2022)</td>
      <td>0.1 - 0.2</td>
      <td>0.1 - 0.2</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>SparseAdapter (He et al., 2022b)</td>
      <td>2.0</td>
      <td>2.0</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>BitFit (Ben-Zaken et al., 2021)</td>
      <td>0.05 - 0.1</td>
      <td>0.05 - 0.1</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
    </tr>
    <tr>
      <td>DiffPruning (Guo et al., 2020)</td>
      <td>200</td>
      <td><strong>0.5</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>Fish-Mask (Sung et al., 2021)</td>
      <td>0.01 - 0.5</td>
      <td>0.01 - 0.5</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>Prompt Tuning (Lester et al., 2021)</td>
      <td>0.1</td>
      <td>0.1</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
    </tr>
    <tr>
      <td>Prefix-Tuning (Li and Liang, 2021)</td>
      <td>0.1 - 4.0</td>
      <td>0.1 - 4.0</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
    </tr>
    <tr>
      <td>IPT (Qin et al., 2021)</td>
      <td>56.0</td>
      <td>56.0</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>MAM Adapter (He et al., 2022a)</td>
      <td>0.5</td>
      <td>0.5</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>Parallel Adapter (He et al., 2022a)</td>
      <td>0.5</td>
      <td>0.5</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>Intrinsic SAID (Aghajanyan et al., 2020)</td>
      <td>0.001 - 0.1</td>
      <td><strong>~0.1 or 100</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>LoRa (Hu et al., 2021)</td>
      <td>0.01 - 0.5</td>
      <td><strong>~0.5 or ~30</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
    </tr>
    <tr>
      <td>UniPELT (Mao et al., 2021)</td>
      <td>1.0</td>
      <td>1.0</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>Compacter (Karimi Mahabadi et al., 2021)</td>
      <td>0.05-0.07</td>
      <td><strong>~0.07 or ~0.1</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>PHM Adapter (Karimi Mahabadi et al., 2021)</td>
      <td>0.2</td>
      <td><strong>~0.2 or ~1.0</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>KronA (Edalati et al., 2022)</td>
      <td>0.07</td>
      <td><strong>~0.07 or ~30.0</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>KronA_Bres (Edalati et al., 2022)</td>
      <td>0.07</td>
      <td><strong>~0.07 or ~1.0</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>(IA)³ (Liu et al., 2022)</td>
      <td>0.02</td>
      <td>0.02</td>
      <td style="color: red;">no</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>Ladder Side-Tuning(Sung et al., 2022)</td>
      <td>7.5</td>
      <td>7.5</td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>FAR (Vucetic et al., 2022)</td>
      <td>6.6-26.4</td>
      <td>6.6-26.4</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
      <td style="color: red;">no</td>
    </tr>
    <tr>
      <td>S4-model (Chen et al., 2023)</td>
      <td>0.5</td>
      <td><strong>more than 0.5</strong></td>
      <td style="color: green;">yes</td>
      <td style="color: green;">yes</td>
      <td style="color: red;">no</td>
    </tr>
  </tbody>
</table>
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2303.15647">[2303.15647] Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning</a>
</div>

Table 2 provides an analysis of the model scales on which PEFT methods have been evaluated, highlighting the typical number of trainable parameters used by each approach. The "trainable parameters" count specifically refers to the parameters adjusted by a gradient optimization algorithm, distinguishing them from "modified parameters," which indicate changes relative to the original model. For reparameterization-based methods, the table reports the parameters both before and after reparameterization.  

---

# Additive Methods  

## Adapters  

Adapter-based methods add extra trainable parameters after the attention and fully connected layers of a frozen pre-trained model to reduce memory usage and accelerate training. The specific implementation of the adapter may vary; it can be a simple extra layer or involve expressing weight updates ∆W as a low-rank decomposition of the weight matrix. In either case, adapters are typically small but demonstrate performance comparable to fully fine-tuned models, enabling the training of larger models with fewer resources.  

The concept of adapters was initially developed for multi-domain image classification ([Rebuffi et al., 2017, 2018](https://proceedings.neurips.cc/paper/2017/file/e7b24b112a44fdd9ee93bdf998c6ca0e-Paper.pdf)) and involved adding domain-specific layers between neural network modules. [Houlsby et al. (2019)](https://arxiv.org/abs/1902.00751) adapted this idea for NLP. They proposed adding fully connected networks after the attention and FFN layers in the Transformer architecture.  

---

## Soft Prompts

Prompt methods have emerged as an efficient way to adapt pre-trained language models to specific tasks without the need for full fine-tuning ([Brown et al., 2020](https://proceedings.neurips.cc/paper/2020/file/1457c0d6bfcb4967418bfb8ac142f64a-Paper.pdf)). The concept involves providing instructions or examples to the model that guide its behavior for the desired task.

There are two main categories of prompt methods:

- **Hard Prompts:** Consist of manually created natural text that instructs the model about the task. For example: "Translate the following text to French:" or "Classify the sentiment as positive or negative:". Although intuitive, they require significant expertise to create effective prompts.

- **Soft Prompts:** Utilize continuous and trainable vectors that are concatenated to input embeddings. Unlike hard prompts, these "virtual tokens" are automatically optimized for the task but are not human-interpretable as they do not correspond to real words. ([Li and Liang, 2021](https://aclanthology.org/2021.acl-long.353/); [Lester et al.](https://arxiv.org/abs/2104.08691), 2021; Liu et al., 2021)

### Prompt Tuning

![Prompt Tuning](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/aOA7XXmuMl-6l5Ie8f2_s.png)

**Concept**:

[Prompt Tuning](https://arxiv.org/abs/2104.08691) proposes adding a trainable tensor, known as a "soft prompt", to the model's input embeddings. This tensor is directly optimized through gradient descent, allowing the model to adjust its behavior without altering the underlying model parameters.

**Implementation:**
- Prompt tokens are initialized randomly or from existing word embeddings
- During training, only the prompt tokens are updated, keeping the base model frozen
- The prompt size (number of tokens) is an adjustable hyperparameter
- Prompts can be reused for different instances of the same task

**Efficiency**:

- Research shows that prompt tuning is more parameter-efficient as model size increases. For example, T5-11B achieves similar performance on the SuperGLUE benchmark with short (5 tokens) and long (150 tokens) soft prompts.
- Model Scale: Prompt tuning becomes comparable to full fine-tuning only in models with over 10 billion parameters, demonstrating its efficiency primarily in large models.
- Inference Overhead: While soft prompts are highly parameter-efficient, they can lead to increased computation due to additional tokens, particularly in transformer models with quadratic complexity.

**Applications and Limitations:**
- Ideal for classification and text generation tasks
- Allows maintaining a single copy of the base model for multiple tasks
- Performance may be inferior to traditional fine-tuning in smaller models
- Interpretability of prompt tokens is limited by their continuous nature

### Prefix Tuning 

![Prefix Tuning](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/jQB646g4oxBXodhNkOMZd.png)

<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2101.00190">\[2101.00190\] Prefix-Tuning: Optimizing Continuous Prompts for Generation</a>
</div>

**Concept**:

[Prefix Tuning](https://arxiv.org/abs/2101.00190) is a fine-tuning method that introduces trainable parameters ('prefixes') across all model layers, preserving the original parameters unchanged. Unlike other approaches that modify only input embeddings, this method optimizes prefixes at multiple levels of the architecture, allowing for more refined and efficient adjustment.

In the image above, it is demonstrated that only the prefixes (red prefix blocks) are optimized, so only the prefix needs to be stored for each task, making the method efficient and modular.

**Implementation**:

- A sequence of task-specific vectors (prefixes) are inserted into the hidden states at each model layer.
- To handle training instability, prefixes are generated through a feed-forward network (FFN), which is optimized during training. After training, only the prefixes are retained and the FFN is discarded.

**Performance**:

- Shows performance close to full fine-tuning, requiring significantly fewer parameters — only about 0.1% of the total model parameters.
- It performs particularly well on natural language generation (NLG) tasks and is especially effective in few-data settings.

**Comparison with Prompt Tuning**:

- Both methods add additional parameters to the model, but prefix tuning inserts these parameters in each layer, while prompt tuning modifies only the input embeddings.
- Prefix tuning, with its integration across layers, achieves performance equivalent to full fine-tuning, but with much greater efficiency, primarily in large models.

### P-tuning

![P-tuning](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/ZLbiTYPJ1TXfT06oaIqMH.png)

<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2103.10385">arXiv:2103.10385v2 \[cs.CL\] 25 Oct 2023</a>
</div>

**Concept**:  

[P-Tuning](https://arxiv.org/abs/2103.10385) is a method developed to optimize the performance of language models in natural language understanding (NLU) tasks, aiming to overcome the limitations of traditional discrete prompts. Based on the soft prompt concept, the method uses a trainable embedding tensor optimized through a specialized prompt encoder — typically a bidirectional LSTM network. This approach allows for more refined model adaptation to specific tasks while maintaining computational efficiency.

**Implementation**:

- The method begins by inserting anchor tokens in the input sequence, which serve as reference points to guide the model in identifying important input components
- Prompt tokens can be flexibly positioned at any position in the input sequence, not limited to the beginning
- Model modification occurs only in the input layer, unlike methods like prefix tuning that affect multiple layers, resulting in a more efficient implementation

**Efficiency/Performance**:

- P-Tuning is more efficient than manually creating prompts, allowing GPT-like models to achieve or surpass BERT-like model performance in NLU tasks.
- In benchmarks like LAMA and SuperGlue, P-Tuning enables GPT models to recover a significant amount of world knowledge and achieve performance comparable or better than similar-sized BERT models.
- It also improves BERT model performance, particularly in supervised and few-shot settings, reducing dependence on extensive prompt engineering.

  ![ptuning-results-1](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/Jt09gYcxLFb-sUSsMrEu6.png)

  <div style="text-align: center; font-size: smaller;">
    Source: <a href="https://arxiv.org/pdf/2103.10385">GPT Understands, Too</a>
  </div>

**Application**:

- Primarily applied to NLU tasks, P-Tuning enables models like GPT to effectively compete in areas traditionally dominated by BERT models.
- It is particularly beneficial for tasks requiring knowledge probing and few-shot learning, where it outperforms state-of-the-art approaches.

**Comparison and Additional Points**:

- Compared to other tuning methods like prefix tuning, P-Tuning is more flexible in prompt positioning and does not require modification of all model layers. Its use of a prompt encoder, particularly LSTM, provides more robust prompt optimization, leading to superior performance in specific benchmarks.

---

## (IA)³

![(IA)³](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/G3i5Kuc-ZOR5Rxxn-vG_R.png)

<div style="text-align: center; font-size: smaller;">
  Source: <a href="https://arxiv.org/pdf/2205.05638">Few-Shot Parameter-Efficient Fine-Tuning is Better and Cheaper than In-Context Learning</a>
</div>

**Concept**:  

[(IA)³](https://arxiv.org/abs/2205.05638) (Infused Adapter by Inhibiting and Amplifying Inner Activations) is a parameter-efficient method designed for fine-tuning transformer models. Unlike traditional fine-tuning, which adjusts a large portion of the model's parameters, (IA)³ modifies only specific learned vectors associated with key, value, and feedforward layers within transformer blocks.  
The method introduces three vectors, lv, lk, and lf, which rescale activations in attention and feedforward layers. This approach keeps most model weights frozen, drastically reducing the number of trainable parameters.

**Implementation**:

- (IA)³ injects these learned vectors into attention (key and value layers) and the second feedforward layer within each transformer block. The vectors are the only trainable parameters during fine-tuning, making the process parameter-efficient.  
- The method maintains the original model architecture and incurs only minimal computational overhead, specifically from the rescaling operations performed by lf.

**Efficiency/Performance**:

- (IA)³ is highly parameter-efficient, updating only about 0.01-0.02% of the total model parameters. For example, in the T0-3B model, it updates just 0.02% of parameters, significantly less than methods like LoRA, which requires 16 times more trainable parameters.  
- Despite its minimal parameter updates, it achieves performance comparable to fully fine-tuned models, often outperforming other parameter-efficient methods like Compacter.

**Application**:

- Applicable to any subset of weight matrices in a neural network, making it versatile for various downstream tasks. By adjusting only a small part of the model, it allows the creation of multiple lightweight and portable models adapted to specific tasks.  
- It is particularly beneficial in scenarios with limited computational resources or where rapid adaptation to new tasks is needed without the overhead of full model retraining.

**Comparison**:

- Compared to other fine-tuning methods like LoRA and Compacter, (IA)³ stands out for its extreme parameter efficiency and minimal overhead. While LoRA also aims to reduce the number of trainable parameters, it achieves even greater efficiency by focusing on rescaling activations with learned vectors instead of updating weight matrices.  
- Unlike adapter-based methods, (IA)³ does not add inference latency, as the learned vectors can be merged with the base model, making it an attractive option for real-time applications.

    ![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/ueivD5u40luH6b0y2Qq27.png)

    <div style="text-align: left; font-size: smaller;">
      Source: <a href="https://arxiv.org/pdf/2205.05638">Few-Shot Parameter-Efficient Fine-Tuning is Better and Cheaper than In-Context Learning</a>
    </div>

- Paper Code: [GitHub \- r-three/t-few: Code for T-Few from "Few-Shot Parameter-Efficient Fine-Tuning is Better and Cheaper than In-Context Learning"](https://github.com/r-three/t-few)  

---

# Reparametrization-based methods

Parameter-efficient fine-tuning methods based on reparametrization leverage low-rank representations to minimize the number of trainable parameters. The notion that neural networks have low-dimensional representations has been extensively explored in empirical and theoretical deep learning analyses.

## Intrinsic SAID

Introduced by [Aghajanyan et al. in 2020](https://arxiv.org/abs/2012.13255), Intrinsic SAID is a fine-tuning method based on the discovery that large language models can be effectively adapted using far fewer parameters than their total size suggests. This method explores the concept of "intrinsic dimensionality" - the idea that there exists a lower-dimensional subspace where fine-tuning can be performed as effectively as in the full parameter space.

**Concept**:

- Intrinsic dimensionality represents the minimum number of parameters necessary to effectively adjust a model for a specific task.
- SAID uses the Fastfood transformation to project updates from a low-dimensional space to the full model space, enabling efficient fine-tuning.
- A key finding is that larger models often have a lower intrinsic dimensionality relative to their total size, making the method especially relevant for LLMs.

**Implementation**:

- The process occurs in three main steps:
  1. Subspace Definition: Identification of intrinsic dimensionality (d) for the specific task through empirical analysis of the model and data
  2. Reparametrization: Use of Fastfood transformation (F) to map parameters from the low-dimensional space (d) to the original space (D). This transformation is an efficient alternative to traditional dense matrices
  3. Update: θ = θ₀ + F(θd), where θ₀ are the original pre-trained parameters and θd are parameters optimized in the low-dimensional space

- The Fastfood transformation offers computational efficiency:
  - Temporal complexity: O(D log d)
  - Spatial complexity: O(D)
  - Does not require storage of large dense matrices

**Experimental Results:**

- Tests on the MRPC (Microsoft Research Paraphrase Corpus) dataset showed that:
  - Larger models require proportionally lower intrinsic dimensionality
  - With just 200 parameters projected into a space of millions or billions of dimensions, it's possible to achieve 90% of full fine-tuning performance
  - This discovery suggests that efficient fine-tuning is not only possible but also more effective in larger models

![INTRINSIC DIMENSIONALITY](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/p21tXgFlXv8YyLAOj6fh7.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2012.13255">arXiv:2012.13255v1 \[cs.LG\] 22 Dec 2020</a>
</div>

In the original paper, they used the MRPC dataset and calculated the intrinsic dimension for each pre-trained model using the SAID method.

**Limitations:**

- Although it reduces the number of trainable parameters, it still requires updating all model weights
- Calculating intrinsic dimensionality can be computationally expensive
- The efficiency of the Fastfood transformation may be compromised on specific deep learning hardware
- Practical implementation can be more complex than methods like LoRA

Intrinsic SAID, despite its practical limitations for very large models, established crucial theoretical foundations that directly influenced the development of more practical methods like LoRA. Its main contribution was mathematically demonstrating that efficient fine-tuning in low-dimensional subspaces is not only possible but an intrinsic property of large-scale models. This discovery paved the way for a new generation of efficient fine-tuning techniques, significantly influencing the direction of research in language model adaptation.

---

## Low-Rank Adaptation (LoRA)

Introduced by [Hu et al. in 2021](https://arxiv.org/abs/2106.09685), LoRA drastically reduces computational costs by decomposing weight updates into lower-rank matrices, minimizing the number of trainable parameters and memory consumption.

![LoRA](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/HLhlrvac5tDFGWGnBM0iC.gif)

**Concept:**  
Deep learning models, like LLMs (Large Language Models), depend on weight matrices that store parameters learned during pre-training. In traditional fine-tuning, these weight matrices (W) are directly updated. LoRA, on the other hand, represents these updates (ΔW) as the product of two low-rank matrices (Wa and Wb): ΔW = WA x Wb

This decomposition drastically reduces the number of trainable parameters while keeping the original weight matrix frozen. This approach is possible due to the concept of **intrinsic dimensionality**, which suggests that large models have room for efficient learning in smaller dimensions. In 2020, a Facebook group published a paper ([Intrinsic Dimensionality Paper](https://arxiv.org/pdf/2012.13255.pdf)) demonstrating this.

**Implementation:**  
LoRA implementation follows these steps:

- **Decomposition:** The weight update matrix ΔWm×n is decomposed into two smaller matrices: (Am×r) and (Br×n), where (r) (rank) is an adjustable hyperparameter.   
    
  There is a theory in linear algebra known as the Rank Factorization Theorem, which states:  

  ***A matrix of size `(m,n)` can be written as the product of two matrices of sizes `(m, r)` and `(r,n)`, respectively, where `r` is the matrix's rank, provided that `r >= 1`.***
    
  This can be visualized with this example:

  ![matrix-r](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/RkurAheXlrEq6t6MITzA-.png)

  The (3,3) matrix of rank 1, like B, can be decomposed into two matrices of sizes (3,1) and (1,3)
  
  Considering large matrices, like LLM layers, this reduction has a significant effect. Considering an LLM with 256 million parameters with a single matrix
  ```python
  W shape = (16000, 16000)
  ```
  Assuming the matrix rank is 300, and W is decomposed into two rank-300 matrices, P and Q. The shapes of P and Q will be:
  ```python
  P shape = (16000, 300)  
  Q shape = (300, 16000)
  ```
  The total number of parameters with decomposition will be: 
  ```python
  16000 * 300 + 300 * 16000 = 9600000 = 9.6 million
  ```

- **Training:** Only matrices (A) and (B) are trained, while (W) remains frozen.
- **Merging:** After fine-tuning, (ΔW) can be merged back into matrix (W), maintaining the model's performance.

In practice, LoRA is typically applied to Transformer attention blocks, such as the Wk and Wv projection matrices in multi-head attention modules.

**Efficiency/Performance:**

- **Parameter Reduction:** A model like GPT-3, with 175 billion parameters, would need to adjust only about 37.7 million parameters using LoRA, representing a reduction of almost 5000 times in computational costs.  
- **Versatility:** LoRA can be selectively applied to parts of the model, such as specific layers, to further optimize performance.  
- **Performance:** Studies show that models fine-tuned with LoRA present results comparable to full fine-tuning, but with lower computational and memory costs.

**Applications:**

- **Language Models:** LoRA was initially designed for LLMs, enabling efficient adjustment of models like GPT, PaLM, and LLaMA.  
- **Diffusion Models:** Due to its efficiency, LoRA has become a popular choice for image generation models like DALL-E and Stable Diffusion.  
- **Variant Creation:** The method facilitates the creation of multiple lightweight variants of a base model, adapted to different tasks.

**Comparison and Additional Benefits:**

- **Overcoming Other PEFT Methods:** LoRA frequently outperforms techniques like BitFit and Adapters, especially in very large models.  
- **Combinability:** The method is orthogonal to other efficient adjustments, like quantization, allowing combinations such as QLoRA.  
- **Latency Elimination:** The possibility of merging adjusted weights into the base model eliminates additional inference latencies, making LoRA ideal for real-time applications.

With these advantages, LoRA represents a milestone in efficient training of large-scale models, impressively balancing cost and performance.

### Quantized Low-Rank Adaptation (QLoRA)

Introduced by [Dettmers et al., 2023](https://arxiv.org/pdf/2305.14314.pdf), QLoRA combines the efficiency of quantization with the low-rank adaptation approach of LoRA, further optimizing fine-tuning for large-scale language models. This technique allows models with up to 65 billion parameters to be fine-tuned on limited GPUs (such as a single 48GB GPU), while preserving the performance of traditional 16-bit fine-tuning methods.

![qlora](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/ep585fAs86RoS8Iv3XZpQ.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2305.14314">QLORA: Efficient Finetuning of Quantized LLMs</a>
</div>

**Concept:**  

QLoRA employs quantization to reduce the numerical precision of model weights, minimizing memory usage while maintaining computational efficiency. Simultaneously, LoRA is applied to perform weight updates with low-rank matrices. This powerful combination significantly reduces computational and memory costs without compromising performance.

Key innovations include:

- **4-bit Normal Float (NF4):** A new data type specifically designed to efficiently represent weights that follow a normal distribution (common in LLMs) using only 4 bits per element. NF4 has demonstrated superiority over FP4 and Int4, significantly improving post-quantization accuracy, as evidenced by lower average perplexity (27.41 vs. 31.07) in tests with models like OPT, BLOOM, LLaMA, and Pythia.  
- **Double Quantization:** Implemented via Hugging Face’s [`bitsandbytes`](https://github.com/bitsandbytes-foundation/bitsandbytes), this reduces average memory usage by also quantizing the quantization constants.  
- **Paged Optimizers:** Manage memory spikes during training.

**Implementation:**  

- **Quantization:** Model weights are quantized to 4 bits using the NF4 technique, reducing memory requirements without losing relevant information.  
- **Fine-tuning:** Low-rank matrices are trained (similar to LoRA), while the original weights remain quantized and frozen.  
- **Preserved Performance:** The approach maintains model precision and effectiveness, even with significant resource reductions.  

**Experimental Results:**  

Experiments with QLoRA demonstrated that it replicates the performance of traditional 16-bit fine-tuning methods, even using 4-bit quantization. This was shown in academic benchmarks such as GLUE, Super-NaturalInstructions, and MMLU. 

<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table"> Table 2: Pile Common Crawl mean
perplexity for different data types
for 125M to 13B OPT, BLOOM,
LLaMA, and Pythia models.
</figcaption>
<table border="1">
    <tr>
        <th>Data type</th>
        <th>Mean PPL</th>
    </tr>
    <tr>
        <td>Int4</td>
        <td>34.34</td>
    </tr>
    <tr>
        <td>Float4 (E2M1)</td>
        <td>31.07</td>
    </tr>
    <tr>
        <td>Float4 (E3M0)</td>
        <td>29.48</td>
    </tr>
    <tr>
        <td>NFloat4 + DQ</td>
        <td>27.41</td>
    </tr>
</table>
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2305.14314">QLORA: Efficient Finetuning of Quantized LLMs - Table 2</a>
</div>

<figcaption class="ltx_caption">
    <span class="ltx_tag ltx_tag_table">Table 3: Experiments comparing 16-bit BrainFloat (BF16), 8-bit Integer (Int8), 4-bit Float (FP4), and 4-bit NormalFloat (NF4) on GLUE and Super-NaturalInstructions. QLORA replicates 16-bit LoRA and full-finetuning.</span>
</figcaption>
<table border="1">
    <tr>
        <th>Dataset</th>
        <th colspan="2">GLUE (Acc.)</th>
        <th colspan="4">Super-NaturalInstructions (RougeL)</th>
    </tr>
    <tr>
        <th>Model</th>
        <th>BF16</th>
        <th>BF16 replication</th>
        <th>LoRA BF16</th>
        <th>QLORA Int8</th>
        <th>QLORA FP4</th>
        <th>QLORA NF4 + DQ</th>
    </tr>
    <tr>
        <td>RoBERTa-large</td>
        <td>88.6</td>
        <td>88.6</td>
        <td>88.8</td>
        <td>88.8</td>
        <td>88.6</td>
        <td>-</td>
    </tr>
    <tr>
        <td>T5-80M</td>
        <td>40.1</td>
        <td>40.0</td>
        <td>40.5</td>
        <td>40.4</td>
        <td>40.3</td>
        <td>40.4</td>
    </tr>
    <tr>
        <td>T5-250M</td>
        <td>42.1</td>
        <td>42.2</td>
        <td>42.6</td>
        <td>42.9</td>
        <td>42.4</td>
        <td>42.7</td>
    </tr>
    <tr>
        <td>T5-780M</td>
        <td>48.0</td>
        <td>47.3</td>
        <td>47.1</td>
        <td>45.4</td>
        <td>47.5</td>
        <td>47.7</td>
    </tr>
    <tr>
        <td>T5-3B</td>
        <td>54.3</td>
        <td>54.9</td>
        <td>55.4</td>
        <td>56.5</td>
        <td>55.6</td>
        <td>55.3</td>
    </tr>
    <tr>
        <td>T5-11B</td>
        <td>62.0</td>
        <td>-</td>
        <td>60.7</td>
        <td>60.7</td>
        <td>60.9</td>
        <td>60.9</td>
    </tr>
</table>
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2305.14314">QLORA: Efficient Finetuning of Quantized LLMs - Table 3</a>
</div>

As shown in Table 2, the NF4 format with double quantization (NFloat4 + DQ) achieves the lowest average perplexity (27.41) among all tested 4-bit formats, highlighting its efficacy in preserving information. Table 3 shows that QLoRA maintains performance close to or equal to 16-bit training (BF16) across different model scales and tasks.

**Efficiency:**  

- **Memory Reduction:** 4-bit quantization reduces memory usage by up to 75% compared to FP16 weights.  
- **Computational Cost:** Combining LoRA with quantization enables fine-tuning of extremely large models using more accessible hardware.  
- **Optimized Performance:** Even with limited resources, QLoRA achieves results comparable to traditional methods, demonstrating practical applicability.

By combining quantization and low-rank adaptation, QLoRA democratizes the fine-tuning of LLMs, enabling researchers and developers with limited computational resources to work with large-scale models without compromising quality.

---

### **Initialization**

The initialization of LoRA weights in the [PEFT library](https://huggingface.co/docs/peft/main/en/developer_guides/lora#pissa) uses Kaiming-uniform for weights A and zeros for B by default, resulting in an identity transformation, consistent with the [reference implementation](https://github.com/microsoft/LoRA).

#### **PiSSA**

![PiSSA](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/L66FgrSCURIxeJFSdUJ6Q.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2404.02948">PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models</a>
</div>

[**PiSSA**](https://arxiv.org/abs/2404.02948) initializes the LoRA adapter using the principal singular values and vectors of the model's original weight matrix (W) to initialize adapters. This direct modification enables PiSSA to converge faster than standard initialization and achieve superior performance by focusing on the model's most relevant components during fine-tuning while keeping residual components frozen. Moreover, PiSSA reduces quantization error compared to QLoRA, leading to additional improvements. 

<table>
  <caption><strong>Comparing PiSSA and LoRA on NLU tasks.</strong></caption>
  <thead>
    <tr>
      <th>Method</th>
      <th>Parameters</th>
      <th>MNLI</th>
      <th>SST-2</th>
      <th>MRPC</th>
      <th>CoLA</th>
      <th>QNLI</th>
      <th>QQP</th>
      <th>RTE</th>
      <th>STS-B</th>
    </tr>
  </thead>
  <tbody>
    <tr class="subtitle">
      <td colspan="10" style="text-align: center"><strong>RoBERTa-large (355M)</strong></td>
    </tr>
    <tr>
      <td>Full FT</td>
      <td>355M</td>
      <td>90.2</td>
      <td><u>96.4</u></td>
      <td><u>90.9</u></td>
      <td>68.0</td>
      <td>94.7</td>
      <td><b>92.2</u></td>
      <td>86.6</td>
      <td>91.5</td>
    </tr>
    <tr>
      <td>LoRA</td>
      <td>1.84M</td>
      <td><u>90.6</u></td>
      <td>96.2</td>
      <td><u>90.9</u></td>
      <td>68.2</td>
      <td>94.9</td>
      <td><u>91.6</u></td>
      <td>87.4</td>
      <td><u>92.6</u></td>
    </tr>
    <tr>
      <td>PiSSA</td>
      <td>1.84M</td>
      <td><b>90.7</b></td>
      <td><b>96.7</b></td>
      <td><b>91.9</b></td>
      <td><b>69.0</b></td>
      <td><b>95.1</b></td>
      <td><u>91.6</u></td>
      <td><b>91.0</b></td>
      <td><b>92.9</b></td>
    </tr>
    <tr class="subtitle">
      <td colspan="10" style="text-align: center"><strong>DeBERTa-v3-base (184M)</strong></td>
    </tr>
    <tr>
      <td>Full FT</td>
      <td>184M</td>
      <td>89.90</td>
      <td>95.63</td>
      <td>89.46</td>
      <td>69.19</td>
      <td>94.03</td>
      <td><b>92.40</b></td>
      <td>83.75</td>
      <td>91.60</td>
    </tr>
    <tr>
      <td>LoRA</td>
      <td>1.33M</td>
      <td><b>90.65</b></td>
      <td>94.95</td>
      <td>89.95</td>
      <td>69.82</td>
      <td>93.87</td>
      <td>91.99</td>
      <td>85.20</td>
      <td>91.60</td>
    </tr>
    <tr>
      <td>PiSSA</td>
      <td>1.33M</td>
      <td>90.43</td>
      <td><b>95.87</b></td>
      <td><b>91.67</b></td>
      <td><b>72.64</b></td>
      <td><b>94.29</b></td>
      <td>92.26</td>
      <td><b>87.00</b></td>
      <td><b>91.88</b></td>
    </tr>
  </tbody>
</table>

![pissa analysss](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/R7tD56bffeUlg_clbEXx7.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2404.02948">PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models</a>
</div>

The images above demonstrate PiSSA's advantages in improving and accelerating convergence and reducing quantization error, as evidenced by experiments in the published paper.

Experiments show that PiSSA consistently outperforms LoRA across various models and tasks, including natural language generation and comprehension benchmarks. For example, in the GSM8K benchmark, the Mistral-7B model fine-tuned with PiSSA achieved 72.86% accuracy, surpassing the 67.7% achieved with LoRA, a significant improvement of 5.16%. Furthermore, PiSSA excels in reducing quantization error compared to QLoRA. The quantized version, QPiSSA, achieved 86.05% accuracy in the same benchmark, outperforming QLoRA's 81.73%.

Thanks to compatibility with quantization techniques and the use of fast SVD for initialization, PiSSA offers a memory-efficient and performance-enhancing solution without sacrificing training speed. Additional evaluations on the GLUE benchmark using RoBERTa-large and DeBERTa-v3-base confirm that PiSSA outperforms LoRA in 14 out of 16 tested tasks, demonstrating superior fine-tuning capability and reduced training loss.

#### **OLoRA**

![OLoRA](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/PB8UeAuVdUnZQpWfGluRr.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2406.01775">OLoRA: Orthonormal Low-Rank Adaptation of Large Language Models</a>
</div>

[OLoRA](https://arxiv.org/abs/2406.01775) (Orthonormal Low-Rank Adaptation) is an efficient parameter adaptation technique that uses QR decomposition to initialize LoRA adapters. Instead of directly applying adaptation to the model weights, OLoRA introduces an orthonormal transformation to the pre-trained weight matrix before any adjustment. It decomposes the weight matrix 𝑊 into an orthogonal matrix 𝑄 and an upper triangular matrix 𝑅. This approach provides greater training stability, accelerates convergence, and leads to superior performance.  

OLoRA is applied independently to each model layer, using the adapted weight matrices during forward propagation, while gradients are calculated only concerning the adaptation matrices during backpropagation. This preserves the original model's knowledge, enabling efficient adjustments with low computational cost.  

Although QR decomposition has an initial computational cost of 𝑂(𝑚𝑛𝑟), it is performed only once per layer during initialization, making the overhead negligible compared to the total cost of training large-scale models.  

![olora-rank-eval](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/sm-DXGkE-uapsy1_txURo.png)
![olora-loss](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/FWhJcefFaNY9rCQpRdQCH.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2406.01775">OLoRA: Orthonormal Low-Rank Adaptation of Large Language Models</a>
</div>

These figures demonstrate the loss behavior during fine-tuning for models such as Tiny-Llama-1.1B, with different ranks, Gemma-2B, and OPT-1.3B, where OLoRA converges more rapidly. These experiments are detailed in the original paper.

#### **Rank-stabilized LoRA (rsLoRA)**

The LoRA architecture scales each adapter during each forward pass by a fixed scalar set during initialization, dependent on the rank \(r\). In the original implementation, this scalar is defined as \( \text{lora\_alpha} / r \), but [**rank-stabilized LoRA (rsLoRA)**](https://huggingface.co/papers/2312.03732) uses \( \text{lora\_alpha} / \sqrt{r} \), stabilizing the adapters and enhancing performance potential when using higher ranks.

![rsLoRA-perplexity](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/Bh57gwX4wl6871yIiedFs.png)

![rsLoRA-gradient-norm](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/mb03XsWmjw7BRS-qbghQW.png)

<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2312.03732">A Rank Stabilization Scaling Factor for Fine-Tuning with LoRA</a>
</div>

In experiments, rsLoRA demonstrated superior performance to LoRA in high-rank configurations. While training the LLaMA 2 model on 20,000 examples from the OpenOrca instruction dataset, it maintained gradient stability even with high ranks, whereas standard LoRA suffered from gradient collapse and lower learning efficiency.

---

#### **Weight-Decomposed Low-Rank Adaptation (DoRA)**

![DoRA](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/tShBdbAVpQZMA6BXfdkUw.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2402.09353">\[2402.09353\] DoRA: Weight-Decomposed Low-Rank Adaptation</a>
</div>

[DoRA](https://arxiv.org/abs/2402.09353) decomposes weight updates into two components: magnitude and direction. Direction is handled by standard LoRA, while magnitude is managed by a separate learnable parameter. This approach enhances LoRA's performance, especially at lower ranks.

Experiments demonstrated that DoRA consistently outperforms LoRA and other fine-tuning methods across models such as LLaMA, LLaVA, and VL-BART in various downstream tasks, including commonsense reasoning, visual instruction tuning, and text-image/video comprehension. For example, on the LLaMA-7B model, DoRA improved average accuracy by 3.7% compared to LoRA on commonsense reasoning datasets, even surpassing ChatGPT's accuracy levels. For larger models like LLaMA-13B, DoRA achieved similar performance to parallel adapters while using only a quarter of the trainable parameters and without increasing inference costs.

**Paper Code:** [GitHub \- NVlabs/DoRA: \[ICML2024 (Oral)\] Official PyTorch implementation of DoRA: Weight-Decomposed Low-Rank Adaptation](https://github.com/NVlabs/DoRA)

---

### **Merge LoRA Adapter**

While LoRA is significantly smaller and faster to train, latency issues may arise during inference due to the separate loading of the base model and the LoRA adapter. To eliminate this latency, you can use the [**`merge_and_unload()`](https://huggingface.co/docs/peft/main/en/package_reference/lora#peft.LoraModel.merge_and_unload)** function to merge the adapter weights with the base model. This enables you to use the newly merged model as a standalone model. The `merge_and_unload()` function does not retain the adapter weights in memory.

Below is a diagram illustrating the intuition behind merging the LoRA adapter:

![merge-lora](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/sIGOBaAZmS9QV7HfWaQKV.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://huggingface.co/docs/peft/main/en/conceptual_guides/lora">Hugging Face</a>
</div>

To keep a separate copy of the weights and allow decoupling of the adapter, you can use [**`merge_adapter()`](https://huggingface.co/docs/peft/main/en/package_reference/tuners#peft.tuners.tuners_utils.BaseTuner.merge_adapter)** and [`unmerge_adapter()`](https://huggingface.co/docs/peft/main/en/package_reference/tuners#peft.tuners.tuners_utils.BaseTuner.unmerge_adapter).

---

### Variations

#### Low-Rank Hadamard Product (LoHa)

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/ZR1cF7OwJZDR9ii5Ief8R.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2309.14859">Navigating Text-To-Image Customization: From LyCORIS Fine-Tuning to Model Evaluation</a>
</div>

**Concept:**  
The Low-Rank Hadamard Product ([LoHa](https://arxiv.org/abs/2108.06098)) utilizes low-rank matrices combined via the Hadamard product (element-wise multiplication) instead of traditional matrix multiplication.

- **∆W Representation:** In LoHa, the weight update matrix ∆W is decomposed into four smaller matrices, and each pair of these low-rank matrices is combined using the Hadamard product. This allows the model to retain high rank and expressiveness while keeping the number of trainable parameters consistent.

**Implementation:**

- **Hadamard Product:** LoHa relies on the Hadamard product instead of matrix multiplication to combine low-rank matrices, affecting the model’s structure and training.
- **Extension of LoRA:** LoHa can be seen as an extension of Low-Rank Adaptation (LoRA), enhancing model capacity without adding more parameters.
- **Embedding Layers:** Although LoHa is applicable to various models, it has not yet been fully implemented in Parameter-Efficient Fine-Tuning (PEFT) frameworks for embedding layers.

**Efficiency and Performance:**

- **Performance Trade-offs:** LoHa balances model expressiveness and the number of parameters. It allows for higher rank and capacity without increasing computational load.
- **Federated Learning (FL):** In FL, LoHa has shown a significant reduction in communication costs (3–10x lower) while maintaining comparable model performance. This is achieved via the FedPara method, which uses low-rank weights followed by the Hadamard product, making it more efficient than traditional low-rank approaches.

**Applications:**  
LoHa was originally developed for computer vision tasks, particularly in diffusion models where generating diverse images is crucial.


#### Low-Rank Kronecker Product (LoKr)

[LoKr](https://arxiv.org/abs/2309.14859) is a LoRA variant, closely related to LoRA and LoHa, primarily applied in diffusion models but also adaptable to other model types. The main difference between LoKr and LoRA is that LoKr replaces traditional matrix multiplication with the Kronecker product. This decomposition creates a block matrix that preserves the structure and rank of the original weight matrix, ensuring the model retains its generalization capabilities during fine-tuning.

**Key Advantages:**

- **Vectorization Capability:** The Kronecker product can be vectorized, meaning the matrix columns can be stacked into a vector. This reduces the need to fully reconstruct the adjustment matrix (∆W), accelerating fine-tuning and enhancing efficiency.  
- **Additional Matrix Flexibility:** LoKr allows for an optional third low-rank matrix, providing more refined control during fine-tuning.  

Although initially designed for diffusion models, LoKr’s flexibility allows integration into a wide range of models, making it an efficient low-rank adaptation technique without compromising the base model’s performance.

#### Mixture of LoRA Experts (X-LoRA)

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/YRBO9FArL-3mU9vUgwqt2.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2402.07148">\[2402.07148\] X-LoRA: Mixture of Low-Rank Adapter Experts, a Flexible Framework for Large Language Models with Applications in Protein Mechanics and Molecular Design</a>
</div> 

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/oORxPXBugLEUpkz10KO-S.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2402.07148">\[2402.07148\] X-LoRA: Mixture of Low-Rank Adapter Experts, a Flexible Framework for Large Language Models with Applications in Protein Mechanics and Molecular Design</a>
</div>  

**Concept:**  
[X-LoRA](https://arxiv.org/abs/2402.07148) is an advanced low-rank adaptation (LoRA) method leveraging the concept of *mixture of experts* (MoE). It dynamically activates different LoRA experts using control mechanisms (gates) that can be dense or sparse. Unlike traditional MoE methods, X-LoRA keeps both LoRA experts and the base model frozen during training, training only the control layers (gates), thereby reducing complexity and training costs.

**Implementation:**

- **Dual Pass:** During inference, X-LoRA performs two steps. First, the model generates hidden states without applying LoRA adapters. Then, these states are used to compute adjustments from LoRA adapters, dynamically reorganizing and selecting the most suitable experts for the task.  
- **Control Layers:** Control layers decide which LoRA experts are activated and adjust their scales precisely, both at the layer and token levels. These are the only parts trained in X-LoRA.  
- **Custom Adaptation:** X-LoRA allows fine-grained adaptation, activating specific LoRA experts for particular layers and tokens, resulting in highly personalized tuning.

**Efficiency and Performance:**

- **Parameter Efficiency:** Since only control layers are trained, while the base model and LoRA experts remain frozen, X-LoRA significantly reduces the number of parameters adjusted, enabling lightweight training without compromising performance.  
- **Dynamic Knowledge Recovery:** The dual-pass mechanism allows the model to "reflect" on its outputs, dynamically adjusting its predictions for improved accuracy and context sensitivity.

**Applications:**  
X-LoRA excels in scientific and technical domains, such as materials analysis, protein mechanics, and molecular design. Its ability to dynamically combine knowledge from different experts makes it highly effective for complex, interdisciplinary problems like predicting nanomechanical properties or molecular behaviors.  

![xlora-gif](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/h30H1VubVjFHftvOb6rjm.gif)

**Comparison and Highlights:**

- **Traditional LoRA vs. X-LoRA:** Unlike standard LoRA, which applies fixed adaptations, X-LoRA introduces dynamic flexibility, enabling more intelligent and specialized adjustments.  
- **Biological Inspiration:** The design of X-LoRA is inspired by biological principles, such as component reuse across hierarchies, enhancing its versatility and applicability across diverse fields.  

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/MH-9IOlUmxVY-CCUtuvLB.png)  
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2402.07148">\[2402.07148\] X-LoRA: Mixture of Low-Rank Adapter Experts, a Flexible Framework for Large Language Models with Applications in Protein Mechanics and Molecular Design</a>
</div> 

These experimental results show knowledge recall evaluation.  
- (a) Results from a bioinspired recall exam, where X-LoRA outperforms other models despite being smaller (7B parameters vs. 13B).  
- (b) Benchmark results for mechanics/materials knowledge recall.  
- (c) Results in biology, materials, protein properties, logic, and reasoning domains, focusing on challenging questions.

---

## **KronA**

![krona](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/P9Qy3OwFw_D4IqkrUcvRE.png)  
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2212.10650">[2212.10650] KronA: Parameter Efficient Tuning with Kronecker Adapter</a>
</div> 

### Concept  
KronA is a parameter-efficient fine-tuning method that extends the idea of matrix factorization used in LoRA by leveraging the Kronecker product. The Kronecker product enables improved order efficiency, i.e., it retains or enhances the rank of the original weight matrices being factorized ([Edalati et al., 2022](https://arxiv.org/abs/2212.10650)).

The Kronecker product used in KronA is represented as δW = WA ⊗ WB, where WA and WB are the matrices involved in the factorization. This approach allows KronA to achieve a better rank-to-parameter ratio compared to traditional matrix factorization methods.

The figure above illustrates the structure of the proposed Kronecker-based modules and their low-rank counterparts. In figure d), KronA^Bres is shown, with the residual connection represented by the dotted line.

### Implementation  

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/z2NwTqyZbNkNl8QEbeeiQ.png)

KronA implements a Kronecker product-vector operation x(A⊗B), avoiding the explicit representation of the update matrix δW. This results in significant computational speedups during both training and inference.

KronA also introduces KronA^Bres, a variant that includes a residual connection and a parallel adapter structure, further optimizing weight parameterization through the Kronecker product.

### Efficiency/Performance  
KronA is highly parameter-efficient, updating only about 0.07% of the total model parameters, similar to methods like LoRA and Compacter. However, it achieves better performance, particularly on tasks within the GLUE benchmark.

The method is not only parameter-efficient but also faster during inference compared to adapter-based methods like Compacter. This is largely due to the efficient computation of the Kronecker product, which avoids the overhead associated with explicit matrix representations.

### Applications  
KronA is particularly useful for models with smaller parameter counts (less than 1 billion). It is well-suited for tasks where parameter efficiency and inference speed are critical, such as real-time applications or resource-constrained environments.

The method has demonstrated strong performance in natural language processing tasks, specifically on the GLUE benchmark, where it matches or outperforms other fine-tuning methods while maintaining a similar or smaller parameter footprint.

---

## **Selective Tuning**

Selective methods adjust a subset of the model's existing parameters. This can involve layer-depth selection, type-based selection, or even individual parameter selection.

### **BitFit**

#### Concept  
BitFit is an efficient fine-tuning technique proposed by ([Ben-Zaken et al., 2021](https://arxiv.org/abs/2106.10199)), which focuses on adjusting only the bias terms of pre-trained models instead of updating all layer weights. In linear or convolutional layers, the weight matrix 𝑊 remains unchanged, while only the bias vector 𝑏 is optimized.

#### Implementation  
The implementation of BitFit is straightforward. The bias terms are selected from the model parameters, and the optimizer works exclusively on these parameters.

This approach modifies only about 0.05% of the model's total parameters, making BitFit highly efficient in terms of storage and computation.

#### Efficiency/Performance  
BitFit demonstrates excellent memory and training time efficiency. By updating a minimal fraction of parameters, it drastically reduces resource requirements, such as memory and computational capacity, especially compared to full fine-tuning. It has shown effectiveness in smaller models, particularly in small to medium data scenarios, where its performance is comparable to or even surpasses full fine-tuning.

However, when applied to larger models, such as T0-3B or GPT-3, BitFit may become less competitive, trailing behind full fine-tuning or other efficient fine-tuning approaches like LoRA or Prefix Tuning. This is because modifying only the bias terms may be insufficient to capture the complexity of training data in larger models.

#### Applications  
BitFit is especially useful in scenarios where computational resources are limited or where rapid model training on new data is required without the capacity for full fine-tuning. It is particularly effective in domains with small or medium training datasets, such as adapting pre-trained language models to specific tasks (e.g., text classification or question answering).

#### Comparison with Other Techniques  
Compared to other efficient fine-tuning techniques like LoRA and Adapters, BitFit is the simplest method, as it only modifies biases. However, its simplicity can lead to inferior performance in scenarios involving large datasets or large models, where techniques like LoRA tend to be more effective.

<table>
  <thead>
      <tr class="header-row">
          <th></th>
          <th></th>
          <th>% Param</th>
          <th>QNLI</th>
          <th>SST-2</th>
          <th>MNLIm</th>
          <th>MNLIm mm</th>
          <th>CoLA</th>
          <th>MRPC</th>
          <th>STS-B</th>
          <th>RTE</th>
          <th>QQP</th>
          <th>Avg.</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td class="first-col"></td>
          <td class="first-col">Train size</td>
          <td></td>
          <td>105k</td>
          <td>67k</td>
          <td>393k</td>
          <td>393k</td>
          <td>8.5k</td>
          <td>3.7k</td>
          <td>7k</td>
          <td>2.5k</td>
          <td>364k</td>
          <td></td>
      </tr>
      <tr>
          <td class="first-col">(V)</td>
          <td class="first-col">Full-FT</td>
          <td>100%</td>
          <td><b>93.5</b></td>
          <td><b>94.1</b></td>
          <td><b>86.5</b></td>
          <td><b>87.1</b></td>
          <td><b>62.8</b></td>
          <td><b>91.9</b></td>
          <td>89.8</td>
          <td>71.8</td>
          <td><b>87.6</b></td>
          <td><b>84.8</b></td>
      </tr>
      <tr>
          <td class="first-col">(V)</td>
          <td class="first-col">Full-FT</td>
          <td>100%</td>
          <td>91.7±0.1</td>
          <td>93.4±0.2</td>
          <td>85.5±0.4</td>
          <td>85.7±0.4</td>
          <td>62.2±1.2</td>
          <td>90.7±0.3</td>
          <td><b>90.0±0.4</b></td>
          <td><b>71.9±1.3</b></td>
          <td>87.5±0.4</td>
          <td>84.1</td>
      </tr>
      <tr>
          <td class="first-col">(V)</td>
          <td class="first-col">Diff-Prune</td>
          <td>0.5%</td>
          <td><b>93.4</b></td>
          <td><b>94.2</b></td>
          <td><b>86.4</b></td>
          <td><b>86.9</b></td>
          <td>63.5</td>
          <td>91.3</td>
          <td>89.5</td>
          <td>71.5</td>
          <td><b>86.6</b></td>
          <td><b>84.6</b></td>
      </tr>
      <tr>
          <td class="first-col">(V)</td>
          <td class="first-col">BitFit</td>
          <td>0.08%</td>
          <td>91.4±2.4</td>
          <td>93.2±0.4</td>
          <td>84.4±0.2</td>
          <td>84.8±0.1</td>
          <td><b>63.6±0.7</b></td>
          <td><b>91.7±0.5</b></td>
          <td><b>90.3±0.1</b></td>
          <td><b>73.2±3.7</b></td>
          <td>85.4±0.1</td>
          <td>84.2</td>
      </tr>
      <tr>
          <td class="first-col">(T)</td>
          <td class="first-col">Full-FTi</td>
          <td>100%</td>
          <td>91.1</td>
          <td><b>94.9</b></td>
          <td>86.7</td>
          <td>85.9</td>
          <td><b>60.5</b></td>
          <td><b>89.3</b></td>
          <td><b>87.6</b></td>
          <td>70.1</td>
          <td><b>72.1</b></td>
          <td><b>81.8</b></td>
      </tr>
      <tr>
          <td class="first-col">(T)</td>
          <td class="first-col">Full-FTt</td>
          <td>100%</td>
          <td><b>93.4</b></td>
          <td>94.1</td>
          <td>86.7</td>
          <td><b>86.0</b></td>
          <td>59.6</td>
          <td>88.9</td>
          <td>86.6</td>
          <td><b>71.2</b></td>
          <td>71.7</td>
          <td>81.5</td>
      </tr>
      <tr>
          <td class="first-col">(T)</td>
          <td class="first-col">Adaptersi</td>
          <td>3.6%</td>
          <td>90.7</td>
          <td>94.0</td>
          <td>84.9</td>
          <td>85.1</td>
          <td>59.5</td>
          <td>89.5</td>
          <td><b>86.9</b></td>
          <td>71.5</td>
          <td><b>71.8</b></td>
          <td>81.1</td>
      </tr>
      <tr>
          <td class="first-col">(T)</td>
          <td class="first-col">Diff-Prune</td>
          <td>0.5%</td>
          <td>93.3</td>
          <td>94.1</td>
          <td><b>86.4</b></td>
          <td><b>86.0</b></td>
          <td><b>61.1</b></td>
          <td><b>89.7</b></td>
          <td>86.0</td>
          <td>70.6</td>
          <td>71.1</td>
          <td><b>81.5</b></td>
      </tr>
      <tr>
          <td class="first-col">(T)</td>
          <td class="first-col">BitFit</td>
          <td>0.08%</td>
          <td>92.0</td>
          <td><b>94.2</b></td>
          <td>84.5</td>
          <td>84.8</td>
          <td>59.7</td>
          <td>88.9</td>
          <td>85.5</td>
          <td><b>72.0</b></td>
          <td>70.5</td>
          <td>80.9</td>
      </tr>
  </tbody>
</table>
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/abs/2106.10199">[2106.10199] BitFit: Simple Parameter-efficient Fine-tuning for Transformer-based Masked Language-models - Table 1</a>
</div> 

*Paper code*: [GitHub \- benzakenelad/BitFit: Simple Parameter-efficient Fine-tuning for Transformer-based Masked Language-models](https://github.com/benzakenelad/BitFit)


## DiffPruning

**Concept:**  

[DiffPruning](https://aclanthology.org/2021.acl-long.378/), a technique proposed by Guo et al. (2020), is an efficient fine-tuning technique aimed at updating neural network weights sparsely. The method introduces a learnable binary mask represented by δ = z ◦ ∆W, where "◦" is the Hadamard product (element-wise multiplication). This mask is trained alongside the model during fine-tuning, as part of a regularization objective.

**Implementation:**  
During fine-tuning, both model weights and the learnable binary mask that decides which parameters will be actually updated are adjusted. This results in a highly efficient and sparse update, reducing the number of modified parameters without affecting the model's performance.

**Efficiency and Performance:**

DiffPruning achieves exceptional parameter efficiency by modifying only about 0.5% of the model's parameters in smaller-scale configurations (<1B parameters). Therefore, it is most suitable for multi-task edge applications (such as mobile devices) where storage is limited. However, by minimizing the number of modified parameters, the technique needs more memory during training, as all parameters are optimized along with the binary mask.

**Application:**  
It is especially useful in scenarios where multiple tasks need to be managed efficiently with restricted storage, such as mobile devices. It is also applicable in situations where new tasks arrive in continuous flow or from different providers, as only a small task-specific difference vector needs to be stored. The technique proved comparable to full fine-tuning in benchmarks like GLUE, while modifying only a fraction of the model's parameters.

**Comparison and Additional Points:**  
It offers favorable scalability as the number of tasks increases, requiring only storage of a small difference vector per task. Although more efficient in terms of modified parameters, the memory cost during training can be higher than in traditional fine-tuning approaches, due to the need to optimize all parameters along with the learnable binary mask.

* **Sparsity Control:** The differentiable approach to L0 norm allows DiffPruning to promote sparse updates in a controlled manner, making it useful for scenarios where saving space and computational resources is crucial.  
* **Multiple Task Adaptation:** By not requiring simultaneous access to all tasks during training, DiffPruning is a viable solution for devices that need to adapt to new tasks continuously, without the need to recalibrate the entire model.

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/mEiBBWm-i5zOZF1Vmvs9Y.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://aclanthology.org/2021.acl-long.378.pdf">Parameter-Efficient Transfer Learning with Diff Pruning</a>
</div> 

In this figure, the left shows the average performance on the GLUE validation set at different target sparsity rates for the methods. The right shows results with BERTlarge on the SQuAD v1.1 validation set.

* *Paper Code*: [GitHub \- dguo98/DiffPruning: Parameter Efficient Transfer Learning with Diff Pruning](https://github.com/dguo98/DiffPruning)

## Freeze and Reconfigure (FAR)

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/UH1hQgrz9Xudg58p4L9Wc.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2205.01541">Efficient Fine-Tuning of BERT Models on the Edge</a>
</div> 

**Concept:**  

The [Freeze and Reconfigure (FAR)](https://arxiv.org/abs/2205.01541) technique is an efficient fine-tuning method aimed at reducing memory consumption and accelerating the training of large language models like BERT. FAR works by freezing part of the model's parameters and focusing only on adjusting the most important parameters. The goal is to reduce resource usage during training, especially in edge scenarios where storage and computational power are limited. The method also reconfigures the model architecture to group frozen and trainable parameters separately, optimizing memory operations.

**Implementation:**  
It operates in two steps:

* **Parameter Identification:** Using a learning metric based on L1 norm, it evaluates which parts of the model are important for adjustment. Then, the columns of the matrices that need to be adjusted are selected.  
* **Dynamic Reconfiguration:** The model's parameters and linear layers are divided into frozen and trainable components. During training, matrix multiplications are performed separately for the components, and the results are concatenated to generate the output.

**Efficiency and Performance:**  
In experiments with DistilBERT on GLUE and SQuAD tasks, it managed to freeze up to 60% of the model's parameters, reducing training time by 30% and memory access time by 47%, without significant performance loss in metrics. This approach provides great flexibility when using modern hardware and frameworks like PyTorch, and after training, parameters can be reconfigured, eliminating any negative impact on inference.

**Application:**  
FAR is particularly effective in edge scenarios, such as mobile devices, where resources are limited. Its main application has been in models like DistilBERT, used in NLP tasks like the GLUE benchmark and SQuAD 2.0, where it showed performance comparable to full fine-tuning, but with only a fraction of parameters being updated (approximately 6%).

**Comparison and Additional Points:**  
Compared with BitFit, which freezes all weights of dense layers, FAR showed superior performance, especially in more complex tasks like SQuAD 2.0. BitFit had a sharp performance drop, particularly in more challenging tasks, where it performed nearly 20% worse in EM and F1 metrics. This demonstrates that FAR is more effective in handling the complexity of these tasks in compressed models like DistilBERT, offering a balance between resource efficiency and performance.

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/KbD9O1_WMbDtFMGmjEYpX.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://arxiv.org/pdf/2205.01541">Efficient Fine-Tuning of BERT Models on the Edge</a>
</div>  

Here's the translation to English, maintaining all details and information:

## FishMask

![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/M7gBaQ5qkkQ6EUw_J3YAj.png)
<div style="text-align: center; font-size: smaller;">
Source: <a href="https://proceedings.neurips.cc/paper/2021/file/cb2653f548f8709598e8b5156738cc51-Paper.pdf">Training Neural Networks with Fixed Sparse Masks</a>
</div>    

**Concept:**  

[FishMask](https://proceedings.neurips.cc/paper/2021/file/cb2653f548f8709598e8b5156738cc51-Paper.pdf) (Fisher-Induced Sparse uncHanging) mask is an efficient fine-tuning technique based on sparse parameter updates, where parameters to be adjusted are selected based on Fisher information. By calculating the importance of each parameter using Fisher information, FishMask creates a sparse mask, allowing only a fixed subset of parameters to be updated during training, while the rest remain frozen. The main objective is to optimize performance while reducing memory and communication costs, especially in distributed learning and transfer learning scenarios.

**Implementation:**

* **Fisher information calculation:** The importance of each parameter is estimated through a diagonal approximation of Fisher information, with the formula:  
    
    ![image/png](https://cdn-uploads.huggingface.co/production/uploads/666b9ef5e6c60b6fc4156675/aT8uUHRD4LGb2EtE5MUQY.png)

	The calculation is performed after computing gradients for all parameters in batches.

* **Selection:** After Fisher calculation, parameters with the highest Fisher value are selected and adjusted. The selection is based on a percentage threshold.
* **Mask:** A mask is created to indicate parameter selection.

**Efficiency:**  
The FishMask technique is designed to reduce memory and communication costs in distributed environments, without significantly compromising model performance. By updating only a small fraction of parameters (typically 1% to 10%), FishMask can maintain performance comparable to methods like Adapters, while being more memory-efficient.

In terms of performance, FishMask presents results similar to techniques like Adapters, but falls short of more advanced methods like LoRA and (IA)³.

**Applications:**  
FishMask is especially useful in scenarios where updating all model parameters would be unfeasible.

**Comparison and Additional Points:**  
Compared to other sparse fine-tuning methods, such as BitFit and DiffPruning, FishMask stands out for pre-computing a fixed mask of important parameters, which avoids the need for dynamic adjustments during training. This provides a significant reduction in computational overhead, especially on modern hardware that may have limited support for dynamic sparse operations.

In experiments, FishMask demonstrated performance comparable to Adapters, but with lower memory cost. However, it does not achieve the performance level of techniques like LoRA and (IA)³, which can adjust parameters more precisely and efficiently across a variety of tasks.

## Referências

* [**PEFT**](https://huggingface.co/docs/peft/main/en/index) \- *Hugging Face.* Acesso em: 22 ago. 2024\.
* [**Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning**](https://arxiv.org/abs/2303.15647) \- Vladislav Lialin, Vijeta Deshpande, Anna Rumshisky, 2023\.  
* [**LoRA: Low-Rank Adaptation of Large Language Models**](https://arxiv.org/abs/2106.09685) \- Edward J. Hu, Yelong Shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, Lu Wang, Weizhu Chen, 2021\.  
* [**Intrinsic Dimensionality Explains the Effectiveness of Language Model Fine-Tuning**](https://arxiv.org/abs/2012.13255) \- Armen Aghajanyan, Luke Zettlemoyer, Sonal Gupta  
* [**PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models**](https://arxiv.org/pdf/2404.02948) \- Fanxu Meng, Zhaohui Wang, Muhan Zhang, 2024\.  
* [**OLoRA: Orthonormal Low-Rank Adaptation of Large Language Models**](https://arxiv.org/pdf/2406.01775) \- Kerim Büyükakyüz, 2024\.  
* [**A Rank Stabilization Scaling Factor for Fine-Tuning with LoRA**](https://arxiv.org/abs/2312.03732) \- Damjan Kalajdzievski, 2023\.  
* [**DoRA: Weight-Decomposed Low-Rank Adaptation**](https://arxiv.org/abs/2402.09353) \- Shih-Yang Liu, Chien-Yi Wang, Hongxu Yin, Pavlo Molchanov, Yu-Chiang Frank Wang, Kwang-Ting Cheng, Min-Hung Chen, 2024\.  
* [**X-LoRA: Mixture of Low-Rank Adapter Experts, a Flexible Framework for Large Language Models with Applications in Protein Mechanics and Molecular Design**](https://arxiv.org/abs/2402.07148) \- Eric L. Buehler, Markus J. Buehler, 2024\.  
* [**KronA: Parameter Efficient Tuning with Kronecker Adapter**](https://arxiv.org/abs/2212.10650) \- Ali Edalati, Marzieh Tahaei, Ivan Kobyzev, Vahid Partovi Nia, James J. Clark, Mehdi Rezagholizadeh, 2022\.  
* [**Language Models are Few-Shot Learners**](https://proceedings.neurips.cc/paper/2020/file/1457c0d6bfcb4967418bfb8ac142f64a-Paper.pdf) \- Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, Dario Amodei, 2020\.  
* [**It’s Not Just Size That Matters: Small Language Models Are Also Few-Shot Learners**](https://aclanthology.org/2021.naacl-main.185) \- Schick & Schütze, NAACL 2021.
* [**The Power of Scale for Parameter-Efficient Prompt Tuning**](https://arxiv.org/abs/2104.08691) \- Brian Lester, Rami Al-Rfou, Noah Constant, 2021\.
* [**GPT Understands, Too**](https://arxiv.org/abs/2103.10385) \- Xiao Liu, Yanan Zheng, Zhengxiao Du, Ming Ding, Yujie Qian, Zhilin Yang, Jie Tang, 2021
* [**Efficient Fine-Tuning of BERT Models on the Edge**](https://arxiv.org/abs/2205.01541) \- Danilo Vucetic, Mohammadreza Tayaranian, Maryam Ziaeefard, James J. Clark, Brett H. Meyer, Warren J. Gross, 2022  
* [**Training Neural Networks with Fixed Sparse Masks**](https://proceedings.neurips.cc/paper/2021/file/cb2653f548f8709598e8b5156738cc51-Paper.pdf) \- Yi-Lin Sung, Varun Nair, and Colin A Raffel, 2021\.  
* [**Few-Shot Parameter-Efficient Fine-Tuning is Better and Cheaper than In-Context Learning**](https://arxiv.org/abs/2205.05638) \- Haokun Liu, Derek Tam, Mohammed Muqeeth, Jay Mohta, Tenghao Huang, Mohit Bansal, Colin Raffel, 2022\.
* [**Generative AI with Large Language Models - Deeplearning.AI, AWS Course**](https://coursera.org/share/84ec3e3b3ee61cc343feabb5ec8bf27f) \- Chris Fregly, Antje Barth, 
Shelbee Eigenbrode, Mike Chambers\.
* [**Finetuning Transformer Models - Codeacademy Course**](https://www.codecademy.com/learn/finetuning-transformer-models) 
* [**HuggingFace PEFT**](https://github.com/huggingface/peft/tree/main) *GitHub* \- Sourab Mangrulkar, Sylvain Gugger, Lysandre Debut, Younes Belkada, Sayak Paul and Benjamin Bossan. Acesso em: 22 ago. 2024\.  
* [**meta-llama/llama-recipes: Scripts for fine-tuning Meta Llama3 with composable FSDP & PEFT methods to cover single/multi-node GPUs. Supports default & custom datasets for applications such as summarization and Q\&A. Supporting a number of candid inference solutions such as HF TGI, VLLM for local or cloud deployment. Demo apps to showcase Meta Llama3 for WhatsApp & Messenger.**](https://github.com/meta-llama/llama-recipes#install-with-pip) *GitHub*. Acesso em: 22 ago. 2024\.  
  [**microsoft/LoRA: Code for loralib, an implementation of "LoRA: Low-Rank Adaptation of Large Language Models."**](https://github.com/microsoft/LoRA) *GitHub* \- Edward J Hu, Yelong Shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, Lu Wang and Weizhu Chen*.* Acesso em: 22 ago. 2024\.

</div>
